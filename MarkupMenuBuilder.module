<?php

/**
* Markup Menu Builder Module for ProcessWire
* This module enables you to display on your website custom menus built using ProcessMenuBuilder
*
* @author Kongondo
*
* https://github.com/kongondo/ProcessMenuBuilder
* Created 1 September 2013
* Major update in March 2015
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class MarkupMenuBuilder extends WireData implements Module {
	
	/**
	 * Return information about this module (required)
	 * @ Requires ProcessMenubuilder
	 *
	 */
	
	public static function getModuleInfo() {
	
		return array(
			'title' => 'Markup Menu Builder',
			'summary' => 'Render menus created by Menu Builder',
			'author' => 'Kongondo',
			'version' => 3,
			'href' => 'http://processwire.com/talk/topic/4451-module-menu-builder/',
			'singular' => true, 
			'autoload' => false, 
			'requires' => 'ProcessMenuBuilder'
		);

	}

	/**
	* Initialise the module. This is an optional initialisation method called before any execute methods.
	*	
	* Initialises various class properties ready for use throughout the class.
	*
	* @access public
	*
	*/	
	public function init() {
		//required
	
	}
		
	/**
	* Prepare menu items for rendering.
	* 
	* On success, send array of menu items to renderMenu().
	*
	* @access public
	* @param Mixed $menu ID, Title, Name of a menu or Array of menu items.
	* @param Array $menuItems Array of menu options.
	* @return Array $menu
	*
	*/		
	public function render($menu = null, Array $options = null) {

		//default (mainly css) menu options. For css, we make no assumptions & don't output default values
		$defaultOptions = array(

				'wrapper_list_type' => 'ul',//ul, ol, nav, div, etc.
				'list_type' => 'li',//li, a, span, etc.
				'menu_css_id' => '',
				'menu_css_class' => '',
				'submenu_css_class' => '',
				'has_children_class' => '',//any menu item that has children
				'first_class'=>'',
				'last_class' => '',
				'current_class' => '',

		);

		$menuItems = '';
		$parentIDs = array();

		//merge menu options set by user
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;


		#### - work on the menu items - ###		
		
		//if we got a populated array of menu items
		if(is_array($menu)) {

			 	if(count($menu)) {
						#//prep IDs of parent items and their child last items (for class = last). format: [parent id] => [id of last item for this parent]
						foreach ($menu as $key => $value) if (isset($value['parent_id'])) $parentIDs[$value['parent_id']] = $key;//overwrite 'parent_id' until last item
						return $this->renderMenu($menu, $options, $parentIDs);
			 	}

			 	else return $this->throwError();

		}

		//if we got a menu title|name
		elseif (is_string($menu)) {

				//grab the menu
				$menuName = $this->sanitizer->pageName($menu);
				$menuParent = wire('pages')->get($this->config->adminRootPageID)->child('name=setup, check_access=0')->child('name=menu-builder, check_access=0');
				$menu = $menuParent->child("name=$menuName, check_access=0");
		}

		//if we got an id
		elseif(is_integer($menu)) {

						//grab the menu
						$menuID = (int) $menu;
						$menu = wire('pages')->get($menu);

		}

		
		//if we got a valid menu page
		if($menu) $menuItems = json_decode($menu->menu_items, true);

		//render menu if we found menu items, else for supersuser throw WireException, else return false
		if(is_array($menuItems)) {			
			//prep IDs of parent items and their child last items (for class = last). format: [parent id] => [id of last item for this parent]
			foreach ($menuItems as $key => $value) if (isset($value['parent_id'])) $parentIDs[$value['parent_id']] = $key;//overwrite 'parent_id' until last item

			return $this->renderMenu($menuItems, $options, $parentIDs);			
		}

		else return $this->throwError();		

	}

	/**
	* Displays a nested list (menu items) of a single menu.
	* 
	* A recursive function to display nested list of menu items.
	*
	* @access private
	* @param Array $menuItems Array of menu items to loop through and display.
	* @param Array $options Array of custom settings for menu and menu items (e.g. CSS classes).
	* @param Array $parentIDs Array of IDs of menu items that are parents/have children. Note: ID = menu IDs, not native PW!
	* @param Int $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	* @return string $out
	*
	*/
	private function renderMenu(Array $menuItems, $options = null, $parentIDs = null, $parent = 0, $first = 0) {

		$total = count($menuItems);
		$cnt = 0;

		$out = "";
		$has_child = false;
		$wTag = $options['wrapper_list_type'];//item wrapper tag. default = <ul>
		$iTag = $options['list_type'];//item tag. default = <li>

		foreach ($menuItems as $id => $item) {

			//set properties
			$title = $item['title'];
			$parentID = isset($item['parent_id']) ? $item['parent_id'] : 0;//if parent_id not set, it means they are top tier items
			$pagesID = isset($item['pages_id']) ? $item['pages_id'] : 0;//for PW pages, use their native IDs
			$url = $pagesID ? wire('pages')->get($pagesID)->url : $item['url'];//for PW pages, use their native URLs
			$newtab = isset($item['newtab']) ? "target='_blank'" : '';
			
			$itemFirst = '';

			//if this menu item is a parent; create the sub-items/child-menu-items
			if ($parentID == $parent) {

				//if this is the first child output '<ul>' or specified $wTag       
				if ($has_child === false) {
					$has_child = true;//This is a parent					
					if ($first == 0) {						
							//assign menu css id and class if provided
							$cssMenuID =  $options['menu_css_id'] ? ' id ="' . $options['menu_css_id'] . '" ' : '';
							$cssMenuClass = $options['menu_css_class'] ? 'class ="' . $options['menu_css_class'] . '"' : '';						
							$out .= "<{$wTag}" . $cssMenuID . $cssMenuClass . '>' . "\n";						
							$first = 1;
					}

					else {
							//assign sub-menu classes if provided
							$cssSubMenuClass = $options['submenu_css_class'] ? 'class ="' . $options['submenu_css_class'] . '"' : '';
							$out .= "\n<{$wTag} {$cssSubMenuClass}>\n";
					}

					//first <li> item
					$itemFirst = $options['first_class'];

				}//end if has child

				//item CSS
				$itemCSSID = isset($item['css_itemid']) ? 'id="' . $item['css_itemid'] . '"' : '';
				$itemCSSClass = isset($item['css_itemclass']) ? $item['css_itemclass'] . ' ' : '';	
				$itemHasChildren = isset($parentIDs[$id]) ? $options['has_children_class'] . ' ' : '';
				$itemLast = (in_array($id, $parentIDs)) || ($total - $cnt == 1) ? $options['last_class'] . ' ' : '';

				$itemCurrent = $pagesID == wire('page')->id ? $options['current_class'] . ' ' : '';
				$classes = rtrim($itemCSSClass . $itemHasChildren . $itemLast . $itemCurrent . $itemFirst);
				$class = strlen($classes) ? 'class="' . $classes .'"' : '';
			
				//if $iTag is empty, apply css id and classes to <a> instead
				if(!$iTag) $out .= "<a {$itemCSSID} {$class} {$newtab} href='{$url}'>{$title}</a>";
				else $out .= "<{$iTag} {$itemCSSID} {$class}><a {$newtab} href='{$url}'>{$title}</a>";
 
				//call function again to generate sub-menu items belonging to this menu item. 
				$out .= $this->renderMenu($menuItems, $options, $parentIDs, $id, $first);

				$out .= $iTag ? "</{$iTag}>\n" : '';//if $iTag specified, close it
				
			}//end if $parentID == $parent

			$cnt++;
		
		}//end foreach


		if ($has_child === true) $out .= "</{$wTag}>\n";
		

		return $out;

	}

	/**
	* Helper function to throw error or return false.
	* 
	* This is called if either no menu or no menu items found.
	* Throws WireException for superusers but returns false for all others.
	*
	* @access public
	* @return WireException or false
	*
	*/
	public function throwError() {

		if($this->user->isSuperuser()) 	throw new WireException($this->_('No menu items found! Confirm that such a menu exists and that it has menu items.'));
		else return false;

	}

}