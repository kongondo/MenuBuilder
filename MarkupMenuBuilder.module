<?php

/**
* Markup Menu Builder Module for ProcessWire
* This module enables you to display on your website custom menus built using ProcessMenuBuilder
*
* @author Kongondo
*
* https://github.com/kongondo/ProcessMenuBuilder
* Created 1 September 2013
* Major update in March 2015
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class MarkupMenuBuilder extends WireData implements Module {
	
	/**
	 * Return information about this module (required)
	 * @ Requires ProcessMenubuilder
	 *
	 */
	
	public static function getModuleInfo() {
	
		return array(
			'title' => 'Markup Menu Builder',
			'summary' => 'Render menus created by Menu Builder',
			'author' => 'Kongondo',
			'version' => 2,
			'href' => 'http://processwire.com/talk/topic/4451-module-menu-builder/',
			'singular' => true, 
			'autoload' => false, 
			'requires' => 'ProcessMenuBuilder'
		);

	}

	/**
	* Initialise the module. This is an optional initialisation method called before any execute methods.
	*	
	* Initialises various class properties ready for use throughout the class.
	*
	* @access public
	*
	*/	
	public function init() {
	//required
	
	}
		
	/**
	* Prepare menu items for rendering.
	* 
	* On success, send array of menu items to renderMenu().
	*
	* @access public
	* @param Mixed $menu ID, Title, Name of a menu or Array of menu items.
	* @param Array $menuItems Array of menu options.
	* @return Array $menu
	*
	*/		
	public function render($menu = null, Array $options = null) {

		//default (mainly css) menu options. For css, we make no assumptions & don't output default values
		$defaultOptions = array(

				'list_type' => 'ul',//ul or ol only
				'menu_css_id' => '',
				'menu_css_class' => '',
				'parent_class' => '',//parent of currently active menu item
				'has_children_class' => '',//any menu item that has children
				'first_class'=>'',
				'last_class' => '',
				'current_class' => '',

		);

		$menuItems = '';
		$parentIDs = array();

		//merge menu options set by user
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;


		#### - work on the menu items - ###
		
		
		//if we got a populated array of menu items
		if(is_array($menu)) {

			 	if(count($menu)) {
						//prep IDs of parent items and render the menu
						foreach ($menu as $key => $value) if (isset($value['parent_id']) && !in_array($value['parent_id'], $parentIDs)) $parentIDs[] = $value['parent_id'];
						return $this->renderMenu($menu, $options, $parentIDs);
			 	}

			 	else return $this->throwError();

		}

		//if we got a menu title|name
		elseif (is_string($menu)) {

				//grab the menu
				$menuName = $this->sanitizer->pageName($menu);
				$menuParent = wire('pages')->get($this->config->adminRootPageID)->child('name=setup, check_access=0')->child('name=menu-builder, check_access=0');
				$menu = $menuParent->child("name=$menuName, check_access=0");
		}

		//if we got an id
		elseif(is_integer($menu)) {

						//grab the menu
						$menuID = (int) $menu;
						$menu = wire('pages')->get($menu);

		}

		
		//if we got a valid menu page
		if($menu) $menuItems = json_decode($menu->menu_items, true);

		//render menu if we found menu items, else for supersuser throw WireException, else return false
		if(is_array($menuItems)) {			
			//prep IDs of parent items and render the menu
			foreach ($menuItems as $key => $value) if (isset($value['parent_id']) && !in_array($value['parent_id'], $parentIDs)) $parentIDs[] = $value['parent_id'];
			return $this->renderMenu($menuItems, $options, $parentIDs);			
		}

		else return $this->throwError();		
   
   }

	/**
	* Displays a nested list (menu items) of a single menu.
	* 
	* This is a recursive function to display list of menu items.
	*
	* @access private
	* @param Array $menuItems Array of menu items to loop through and display.
	* @param Array $options Array of custom settings for menu and menu items (e.g. CSS classes).
	* @param Array $parentIDs Array of IDs of menu items that are parents/have children. Note: ID = menu IDs, not native PW!
	* @param Int $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	* @return string $out
	*
	*/
	private function renderMenu(Array $menuItems, $options = null, $parentIDs = null, $parent = 0, $first = 0) {

		$has_child = false;
		$out = "";

        foreach ($menuItems as $id => $item) {

        	//set properties
			$title = $item['title'];
			$parentID = isset($item['parent_id']) ? $item['parent_id'] : 0;//if parent_id not set, it means they are top tier items
			$pagesID = isset($item['pages_id']) ? $item['pages_id'] : 0;//for PW pages, use their native IDs
			$url = $pagesID ? wire('pages')->get($pagesID)->url : $item['url'];//for PW pages, use their native URLs
			$newtab = isset($item['newtab']) ? "target='_blank'" : '';
			
			//CSS @@todo parent_class, last_class, first_class
			$itemCSSID = isset($item['css_itemid']) ? 'id="' . $item['css_itemid'] . '"' : '';

			$itemCSSClass = isset($item['css_itemclass']) ? $item['css_itemclass'] . ' ' : '';	
			$itemHasChildren = in_array($id, $parentIDs) ? $options['has_children_class'] . ' ' : '';
			#$itemHasChildren = in_array($id, $parentIDs) ? 'has_children_class ' : '';
			$itemCurrent = $pagesID == wire('page')->id ? $options['current_class'] : '';
			
			//apply all css classes to <a>
			$classes = rtrim($itemCSSClass . $itemHasChildren . $itemCurrent);
			$class = strlen($classes) ? 'class="' . $classes .'"' : '';		

			//if this menu item is a parent; create the sub-items/child-menu-items
			if ($parentID == $parent) {

                //if this is the first child output '<ul>'           
                if ($has_child === false) {
				
					$has_child = true;//This is a parent
					
					if ($first == 0){
						
						//assign menu css id and class if provided
						$cssMenuID =  $options['menu_css_id'] ? ' id ="' . $options['menu_css_id'] . '" ' : '';
						$cssMenuClass = $options['menu_css_class'] ? 'class ="' . $options['menu_css_class'] . '"' : '';
						
						$out .= '<ul ' . $cssMenuID . $cssMenuClass . '>' . "\n";
						
						$first = 1;
					} 
					
					else {
						$out .= "\n<ul>\n";
					}
                }

				//we apply css classes to <a> but css id to <li>
				$out .= "<li {$itemCSSID}><a {$newtab} {$class} href='{$url}'>{$title}</a>";
 
				//call function again to generate sub-menu items belonging to this menu item. 
				$out .= $this->renderMenu($menuItems, $options, $parentIDs, $id, $first);

                $out .= "</li>\n";
				
            }//end if $parentID == $parent

        }//end foreach
        

		if ($has_child === true) $out .= "</ul>\n";

		return $out;

	}

	/**
	* Helper function to throw error or return false.
	* 
	* This is called if either no menu or no menu items found.
	* Throws WireException for superusers but returns false for all others.
	*
	* @access public
	* @return WireException or false
	*
	*/
	public function throwError() {

		if($this->user->isSuperuser()) 	throw new WireException($this->_('No menu items found! Confirm that such a menu exists and that it has menu items.'));
		else return false;

	}

}