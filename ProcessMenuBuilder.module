<?php

/**
* Process Menu Builder Module for ProcessWire
* This module enables you to create custom menus for your website using drag and drop in the ProcessWire Admin Panel
*
* @author Kongondo
*
* https://github.com/kongondo/ProcessMenuBuilder
* Created 4 August 2013
* Major update in March 2015
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class ProcessMenuBuilder extends Process implements Module {
	
	/**
	 * Return information about this module (required)
	 *
	 */
	
	public static function getModuleInfo() {
	
		//@ User role needs 'menu-builder' permission
		//@ $permission = 'menu-builder';
		//@ Installs MarkupMenuBuilder

		return array(
			'title' => 'Menu Builder',
			'summary' => 'Easy, drag and drop menu builder',
			'author' => 'Kongondo',
			'version' => 3,
			'href' => 'http://processwire.com/talk/topic/4451-module-menu-builder/',
			'singular' => true, 
			'autoload' => false, 
			'permission' => 'menu-builder',
			'installs' => 'MarkupMenuBuilder'
		);

	}
	
		
	const PAGE_NAME = 'menu-builder';

	/**
	* Helper property to return this module's admin page (parent of all menus).
	*
	*/
	protected $menusParent;

	/**
	* string name of the cookie used to save limit of posts to show per page in posts dashboard.
	*
	*/
	private $cookieName;

	/**
	 * int value of number of posts/categories/tags to show per page respective dashboard page.
	 *
	 */
	private $showLimit;

	/**
	* Initialise the module. This is an optional initialisation method called before any execute methods.
	*	
	* Initialises various class properties ready for use throughout the class.
	*
	* @access public
	*
	*/
	public function init() {

		if ($this->permissions->get('menu-builder')->id && !$this->user->hasPermission('menu-builder'))
			 throw new WirePermissionException("You have no permission to use this module");		

		$this->modules->get('JqueryWireTabs');
		$this->config->scripts->add($this->config->urls->ProcessMenuBuilder . 'scripts/jquery.mjs.nestedSortable.js');
		$this->config->scripts->add($this->config->urls->ProcessMenuBuilder . 'scripts/jquery.asmselect-mb.js');
		wire('page')->addHookAfter("InputfieldAsmSelect::render", $this, "customAsm");
		wire('page')->addHookBefore("InputfieldPageAutocomplete::renderListItem", $this, "customAc");

		$this->menusParent = wire('page');

		//cookie per user to save state of number of menus to display per pagination screen in execute()
		$this->cookieName = $this->user->id . '-menubuilder';

		//default number of menus to show in menu builder landing page if no custom limit set (via post/session cookie).
		$this->showLimit = 10;

		parent::init();

	}	
	
	/**
	* Displays a list of the menus.
	* 
	* This function is executed when a menu with Menu Builder Process assigned is accessed. 
	*
	* @access public
	* @return mixed $form
	*
	*/
	public function ___execute() {

		//CREATE A NEW FORM
		$form = $this->modules->get('InputfieldForm'); 
		$form->attr('id', 'menu-builder'); 
		$form->action = './';
		$form->method = 'post';

		//CREATE A NEW WRAPPER
		$w = new InputfieldWrapper;
	
		//quick menus create code
		$m = $this->modules->get('InputfieldMarkup');
		$m->label = $this->_('Add menus');
		$m->description = $this->_('One menu title per line.');
		$m->collapsed = Inputfield::collapsedYes;

		$txa = $this->modules->get('InputfieldTextarea');
		$txa->attr('name', 'menus_add_text');
		$txa->skipLabel = Inputfield::skipLabelHeader;//we don't want a label displayed here

		$m->add($txa);

		//submit button to save quick menus create [save unpublished!]
		$s = $this->modules->get('InputfieldSubmit'); 
		$s->attr('id+name', 'menu_new_unpublished_btn'); 
		$s->attr('value', $this->_('Save Unpublished'));
		$s->class .= " menu_new_unpublished";//add a custom class to this submit button

		$m->add($s);

		//submit button to save AND publish quick menus create
		$s = $this->modules->get('InputfieldSubmit'); 
		$s->attr('id+name', 'menu_new_published_btn'); 
		$s->attr('value', $this->_('Publish'));
		$s->class .= " menu_new_publish";//add a custom class to this submit button
		
		$m->add($s);		

		$w->add($m);

		//...END - QUICK MENU CREATE CODE

		//CREATE AN INPUTFIELD MARKUP: Will hold list of menus table
		$m = $this->modules->get('InputfieldMarkup');
			
		//CREATE A NEW TABLE: for menus
		$t = $this->modules->get('MarkupAdminDataTable');
		$t->setEncodeEntities(false);
		$t->setClass('menus_table');
		
		//set header rows
		$t->headerRow(array(

			'<input type="checkbox" class="toggle_all">',
			$this->_('Title'),
			$this->_('Menu Items'),
			$this->_('Published'),
			$this->_('Locked'),
			$this->_('Modified'),

		));

		//Determine number of menus to show per page in menus tab. Default = 10 {see $this->showLimit}
		
		//if user selects a limit ($input->post->show_limit) we set that as the limit and set a cookie {see $this->cookieName} with that value to save state for session.
		if ($this->input->post->show_limit) {

					$this->showLimit = $this->input->post->show_limit;
					setcookie($this->cookieName, $this->showLimit , 0, '/');
		}

		//if no custom limit selected but there is a cookie set, we use the cookie value
		elseif ($this->input->cookie[$this->cookieName]) {

					$this->showLimit = (int) $this->input->cookie[$this->cookieName];
		}

		//grab a limited number of menus to show in menus tab. Limit is determined as shown above
		$menus = $this->menusParent->children("include=all, sort=title, limit={$this->showLimit}");

		if (count($menus)) {			

				foreach ($menus as $menu) {

						//count number of menu items in each menu
						$menuItemsJSON = $menu->menu_items;
						$menuItemsCnt = count(json_decode($menuItemsJSON, true));
						
						//check if menu is published or not
						$menu->is(Page::statusUnpublished) ? $pubStatus = '<span class="unpublished">' . $this->_('No') . '</span>' : $pubStatus = $this->_('Yes');

						//check if menu is locked for editing
						$menu->is(Page::statusLocked) ? $editStatus = '<span class="locked">' . $this->_('Yes') . '</span>' : $editStatus = $this->_('No');
					
						$modified = wireRelativeTimeStr($menu->modified);

						//set table rows
						$menusTable = array(
												"<input type='checkbox' name='menus_action[]' value='{$menu->id}' class='toggle'>",//disabled sorting on this in .js file
												"<a href='{$this->menusParent->url}edit/?id={$menu->id}'>$menu->title</a>",
												$menuItemsCnt,
												$pubStatus,//menu published status
												$editStatus,//menu locked status
												$modified,
						
						);

						
						//render the table rows with variables set above
						$t->row($menusTable);

				}//end foreach $menus as $menu
		
		}//end if count $menus

		
		//prepare values for 'Show XX Posts', i.e. number of menus to show per page in menus tab
		$limitSelect = '';
		$limitSelect .= '<span class="limit-select">' . $this->_('Show ') . '<select id="limit" name="show_limit">';

		$limits = array( '', 5, 10, 15, 25, 50, 75, 100);

		foreach ($limits as $limit) {
					
					$limitSelect .='<option value="' . $limit . '"' . ($this->showLimit == $limit ? 'selected="selected"':'') . '>' . $limit . '</option>';
		}

		$limitSelect .= '</select>'. $this->_(' Items') . '</span>';

		//display a headline indicating quantities. We'll add this to menus tab
		$start = $menus->getStart()+1;
		$end = $start + count($menus)-1;
		$total = $menus->getTotal();

		if($total) $menusCount = "<h4>" . sprintf(__('Menus %1$d to %2$d of %3$d'), $start, $end, $total) . "</h4>";

		//add a description to menus tab {menusCount, limitSelect and instruction OR no menus found status}
		$m->description = $total == 0 ? $this->_('No menus found.') : $menusCount . $this->_('Click on a title to edit the menu.') . $limitSelect;

		$currentUrl = wire('page')->url . wire('input')->urlSegmentsStr."/";//get the url segment string.
		$pagination = $menus->renderPager(array('baseUrl' => $currentUrl));//just foolproofing

		$m->attr('value', $pagination . $t->render() . $pagination);//wrap our table with pagination

		$w->add($m);

		//only show actions if menus found
		if ($total !=0) {
			
			//the menus bulk actions panel
			$actions = array(
								'publish' => $this->_('Publish'),
								'unpublish' => $this->_('Unpublish'),
								'lock' => $this->_('Lock'),
								'unlock' => $this->_('Unlock'),
								'trash' => $this->_('Trash'),
								'delete' => $this->_('Delete'),

			);

			$m = $this->modules->get('InputfieldMarkup');
			$m->label = $this->_('Actions');
			$m->collapsed = 1;
			$m->description = $this->_('Choose an Action to be applied to the selected menus.');
			
			$is = $this->modules->get('InputfieldSelect');
			$is->label = $this->_('Action');
			$is->attr('name+id', 'menus_action_select');
			$is->addOptions($actions);
			
			$s = $this->modules->get('InputfieldSubmit'); 
			$s->attr('id+name', 'menus_action_btn');
			$s->class .= " posts_action";//add a custom class to this submit button
			$s->attr('value', $this->_('Apply')); 
			
			$m->add($is);//add the input select
			$m->add($s);//add the apply button

			$w->add($m);

		}		


		$form->add($w);	
		
		$post = $this->input->post; 

		//send input->post values to the Method save();
		if($post->menus_action_btn || $post->menu_new_unpublished_btn || $post->menu_new_published_btn) $this->save($form);
		
		//render the final form
		return $form->render();	
						
	}
	
	/**
	* Renders a single menu for editing.
	*
	* Called when the URL is Menu Builders page URL + "/edit/" 
	* note: matches what is appended after ___execute below
	*
	* @access public
	* @return mixed $form
	*
	*/
	public function ___executeEdit() {

		//get the menu (page) we are editing
		$menuID = $this->input->get->id;

		$menu = wire('pages')->get("id=$menuID, parent=$this->menusParent, include=all");//only get menu pages!

		$post = $this->input->post;	
		$form = $this->modules->get('InputfieldForm');

		//if we found a valid menu page
		if($menu->id) {

			$this->nestedSortableConfigs($menu->menu_settings);

			$status = '';
			//check if menu is published or not
			$menu->is(Page::statusUnpublished) ? $pubStatus = 1 : $pubStatus = '';

			//check if menu is locked for editing
			$menu->is(Page::statusLocked) ? $editStatus = 1 : $editStatus = '';

			$editStatusNote = $editStatus ? $this->_(' (locked)') : '';

			//add a breadcrumb that returns to our main page @@todo - don't show non-superadmins breadcrumbs?
			$this->breadcrumbs->add(new Breadcrumb('../', $this->page->title));
			$this->headline(sprintf(__('Edit menu: %s'), $menu->title) . $editStatusNote); //headline when editing a menu

			$form->attr('id', 'MenuBuilderEdit'); 
			$form->action = './';
			$form->method = 'post';


			############################################ - First Tab - ############################################
			
			//fetch this menu's JSON string with menu pages properties (pages find selector and inputfield to use)
			$menuPagesJSON = $menu->menu_pages;
			$menuPages = array();
			
			if($menuPagesJSON) $menuPages = json_decode($menu->menu_pages, true);

			$form->add($this->editTabMenu($menu->title, $pubStatus, $editStatus, $menuPages, $menu->menu_settings));


			############################################ - Second Tab - ############################################			
				
			//fetch this menus JSON string with menu items properties
			$menuItemsJSON = $menu->menu_items;
			$menuItems = array();

			if($menuItemsJSON) $menuItems = json_decode($menu->menu_items, true);
			
			$form->add($this->editTabBuild($menuItems, $menuPages));

			
			############################################ - Third Tab - ############################################


			$form->add($this->editTabOverview($menuItems));


			############################################ - Fourth Tab - ############################################


			$form->add($this->editTabDelete($menu->id));


			/***************** Add input buttons to Fourth tab *****************/

			$h = $this->modules->get('InputfieldHidden'); 
			$h->attr('name', 'menu_id'); 
			$h->attr('value', $menuID); 
			$form->add($h); 

			$s = $this->modules->get('InputfieldSubmit'); 
			$s->class .= ' head_button_clone';
			$s->attr('id+name', 'menu_save');
			$s->class .= " menu_save";//add a custom class to this submit button
			$s->attr('value', $this->_('Save')); 
			$form->add($s); 

			$s = $this->modules->get('InputfieldSubmit'); 
			$s->attr('id+name', 'menu_save_exit'); 
			$s->class .= " ui-priority-secondary";
			$s->class .= " menu_save";//add a custom class to this submit button
			$s->attr('value', $this->_('Save & Exit')); 
			$form->add($s);

			
			return $form->render();

		}//end if $menu


		############################################ - if input->post - ############################################			

		//if saving menu
		elseif($post->menu_save || $post->menu_save_exit || $post->menu_delete) {

			$this->save($form);


		}

		//else invalid menu ID or no ID provided (e.g. /edit/)
		else {

			$this->session->redirect(wire('page')->url);//redirect to landing page
		}		

	}

	/**
	* First tab contents for executeEdit().
	* 
	* @access protected
	* @param String $title Title of the menu being edited.
	* @param String $unpublished Whether the menu being edited is unpublished.
	* @param String $locked Whether the menu being edited is locked.
	* @param Array $menuPages Array of selector and page inputfield type values.
	* @param String $menuSettings JSON string of menu settings (for nestedSortable) of the menu being edited.
	* @return mixed $inputfield markup
	*
	*/
	protected function editTabMenu($title, $unpublished = null, $locked = null, $menuPages, $menuSettings) {

		//First Tab - Main
		$tab = new InputfieldWrapper();
		$tab->attr('title', $this->_('Main')); 
		$id = $this->className() . 'Main';
		$tab->attr('id', $id); 
		$tab->class .= ' WireTab';

		$tx = $this->modules->get('InputfieldText');
		$tx->label = $this->_('Menu title');
		$tx->required = true;
		$tx->attr('name', 'menu_title');
		$tx->attr('value', $title); 
		$tx->description = $this->_('A menu title is required.');

		$notes = ($unpublished || $locked) ? $this->_('Menu status: ') : '';
		if ($unpublished) $notes .= $this->_('Unpublished, ');
		if ($locked) $notes .= $this->_('Locked');		

		$tx->notes = rtrim($notes, ', ');
		
		$tab->add($tx);

		//display configurable backend menu settings for supersuers: @@todo - also make permission-based?
		//options for nestedSortable + ProcessWire selector for pages selectable in $menuAddPageItems AsmSelect

		if($this->user->isSuperuser()) {

			$menuID = $this->input->get->id;

			//if selector to find pages to add to menu specified
			$selectorValue = isset($menuPages['sel']) ? $menuPages['sel'] : '';

			$tx = $this->modules->get('InputfieldText');
			$tx->attr('name', 'menu_pages');
			$tx->label = $this->_('Pages selectable in menu');
			$tx->attr('value', $selectorValue); 
			$tx->description = $this->_('Optionally, you can specify a valid ProcessWire selector to limit the Pages that can be added to this menu (see Build Menu Tab). Otherwise, all valid pages will be available to add to the menu.');
			$tx->notes =  $this->_('Example: parent=/products/, template=product, sort=title');

			$tab->add($tx);

			//only 'PageAutocomplete' option is saved in the field menu_pages (JSON): 'input'=> 2. Else we assume default 'input' => 1 (AsmSelect)
			$pageSel = isset($menuPages['input']) ? 2 : 1;
			
			//radios: page inputfield selection
			$r = new InputfieldRadios();
			$r->attr('id+name', 'menu_pages_select');
			$r->label =  $this->_('Choose a method for selecting pages to add to your menu');
			$r->notes = $this->_('If you will have a large selection of pages to choose from, you may want to use Page Auto Complete.');

			$radioOptions = array (
							 1 => $this->_('Asm Select'),
							 2 => $this->_('Page Auto Complete'),

		 	);

			$r->addOptions($radioOptions);
			$r->value = $pageSel;

			$tab->add($r);

			
			//only 'Allow Markup' (Yes) option is saved in the field menu_pages (JSON): 'markup'=> 2. Else we assume default 'markup' => 1 (No)
			$allowMarkup = isset($menuPages['markup']) ? 1 : 2;

			//radios: allow markup in menu item title/label
			$r = new InputfieldRadios();
			$r->attr('id+name', 'menu_item_title_markup');
			$r->label =  $this->_('Allow HTML in menu items title');
			$r->notes = $this->_('Example: <span>Home</span>. If you allow this, the HTML will be run through HTML purifier before saving. Take care not to input malformed HTML.');

			$radioOptions = array (
							 1 => $this->_('Yes'),
							 2 => $this->_('No'),

		 	);

			$r->addOptions($radioOptions);
			$r->value = $allowMarkup;

			$tab->add($r);

			$t = $this->modules->get('MarkupAdminDataTable');
			$t->setEncodeEntities(false);
			$t->setSortable(false);
			$t->setClass('menu_items_table');

			$t->headerRow(array(
				$this->_('Name'),
				$this->_('Default'),//for PW pages, actual title saved. The title can also be edited in the add menu item settings
				$this->_('Setting'),//path to PW pages + normal url for custom menu items
				$this->_('Notes'),//parent in this menu! NOT PW PAGE PARENT!
			));

			//advanced/optional settings for nestedSortable
			$mergedMenuSettings = $this->nestedSortableMenuSettings($menuSettings);

			foreach ($mergedMenuSettings as $key => $value) {			
					
					$t->row(array(
								$key,//name
								$value['default'],//default value
								"<input type='text' name='menu_settings[" . $key . "]' value='" . $value['setting'] . "'>",//setting - saved in menu_settings as JSON
								$value['notes'],

					));


			}//end foreach $menuSettings

			$m = $this->modules->get('InputfieldMarkup');
			$m->attr('id', 'menu_settings');
			$m->label = $this->_('Menu settings');
			$m->description = $this->_('These are optional settings for') .  ' <a href="https://github.com/ilikenwf/nestedSortable" target="_blank">nestedSortable</a> ' . 
			$this->_('(the Drag and Drop menu functionality in Build Menu Tab).');
			$m->notes = $this->_('Note: These settings do not affect how your menu is displayed in the frontend.');
			$m->collapsed = Inputfield::collapsedYes;
			$m->attr('value', $t->render());		

			$tab->add($m);

		}

		return $tab;

	}


	/**
	* Second tab contents for executeEdit()
	*
	* @access protected
	* @param Array $menuItems Array of menu items for the menu being edited.
	* @param Array $menuPages Array of selector and page inputfield type values.
	* @return mixed $inputfield markup
	*
	*/
	protected function editTabBuild($menuItems, $menuPages) {

		//Second Tab - Drag & Drop + add menu items. Only show if a menu exists

		$tab = new InputfieldWrapper();
		$tab->attr('title', $this->_('Build Menu'));
		$id = $this->className() . 'Build';
		$tab->attr('id', $id); 
		$tab->class .= " WireTab";

		$m = $this->modules->get('InputfieldMarkup');
		$m->label = $this->_('Add menu items');	
		$m->description = '<span id="add_menu_items"><a href="#" id="add_page_menu_items">' . $this->_('Pages') . '</a> ';
		$m->description .= '<a href="#" id="add_custom_menu_items">' . $this->_('Custom') . '</a>';
		if($this->user->isSuperuser()) $m->description .= '<a href="#" id="add_selector_menu_items">' . $this->_('Selector') . '</a>';
		$m->description .= '</span>';
		
		$tab->add($m);	
		
		//if user specified (hence limited) the pages selectable for adding to this menu, we use that
		//if user has not specified pages to return, we find all pages (except admin) but limit to 50.
		//@@todo - maybe also check if user has permission to view those pages?
		if(isset($menuPages['sel'])) $pagesSelector = $menuPages['sel'];
		else $pagesSelector = "has_parent!=2, parent!=7, id!=27, limit=50";

		$description = $this->_('Select Pages to add to your menu. Optionally enter a CSS ID and single/multiple Classes.');
		$menuPagesInput = 1;

		if (isset($menuPages['input']) && $menuPages['input'] == 2) {

				//if we are using page autocomplete inputfield to find pages for menu items selection
				$menuAddPageItems = $this->modules->get('InputfieldPageAutocomplete');
				$menuAddPageItems->set('findPagesSelector', $pagesSelector);
				$menuAddPageItems->notes = $this->_('Start typing to search for pages.');

				//we'll use this class property when saving PageAutocomplete values
				//especially important for non-superusers since the radio input 'menu_pages_select' will not be output for them
				$menuPagesInput = 2;
		}

		//else we default to AsmSelect inputfield
		else {
				
				$opts = wire('pages')->find($pagesSelector);
				if(!count($opts)) {
					$this->error($this->_('Your selector did not find any selectable pages for your menu! Confirm its validity.'));
					$description = $this->_('No pages were found to add to your menu. Rectify the specified error first.');
				}				

				$menuAddPageItems = $this->modules->get('InputfieldAsmSelect');

				foreach($opts as $opt) $menuAddPageItems->addOption($opt->id, $opt->title);

		}

		//Page Select to add menu items from pages		
		$menuAddPageItems->label = $this->_('Pages');
		$menuAddPageItems->attr('name+id', 'item_addpages');
		$menuAddPageItems->description = $description;

		$tab->add($menuAddPageItems);//add page asmSelect/autocomplete to markup	

		//hidden field to store value if using PageAutocomplete to select menu items from pages
		$h = $this->modules->get('InputfieldHidden');
		$h->attr('name', 'menu_pages_input');
		$h->attr('value', $menuPagesInput); 

		$tab->add($h);//add hidden field to markup

		//Add Custom menu items
		$t = $this->modules->get('MarkupAdminDataTable');
		$t->setEncodeEntities(false);
		$t->setSortable(false);
		$t->setClass('menu_add_custom_items_table');

		$t->headerRow(array(
			$this->_('Title'),
			$this->_('Link'),
			$this->_('CSS ID'),
			$this->_('CSS Class'),
			$this->_('New Tab'),
			/*'<a title="Delete All" href="#" class="remove_row"><span class="ui-icon ui-icon-trash"></span></a>',*/
		)); 

		$n = $this->modules->get('InputfieldName');
		$n->required = true;
		$n->attr('name', 'new_item_custom_title[]');
		$n->attr('class', 'new_custom');
		
		$u = $this->modules->get('InputfieldURL');
		$u->attr('name', 'new_item_custom_url[]');
		#$u->required = true;// may not work since in table. Check other ways both cs & ss
		$u->attr('class', 'new_custom');
		
		$n2 = $this->modules->get('InputfieldName');
		$n2->attr('name', 'new_css_itemid[]');
		$n2->attr('class', 'new_custom');
					
		$n3 = $this->modules->get('InputfieldName');
		$n3->attr('name', 'new_css_itemclass[]');
		$n3->attr('class', 'new_custom');					
		
		$itemCustomNewTab = "<input type='checkbox' name='new_newtab[]' class='newtab'>";
	
		$t->row(array(
			$n->render(),
			$u->render(),
			$n2->render(),
			$n3->render(),
			$itemCustomNewTab,
			'<a href="#" class="remove_row"><i class="fa fa-trash"></i></a>',
		));


		$addRow = "<a class='addrow' href='#'>" . $this->_('add row') . "</a>";
		
		$m = $this->modules->get('InputfieldMarkup');
		$m->attr('id', 'item_addcustom');
		$m->label = $this->_('Custom links');
		$m->description = $this->_('Add custom menu items. Title and Link are required.');
		$m->attr('value', $addRow . $t->render());

		$tab->add($m);

		//@@todo - add for other users with othe specified permission?
		//Add menu items from pages returned by a selector
		if($this->user->isSuperuser()) {

			$tx = $this->modules->get('InputfieldText');
			$tx->label = $this->_('Pages search');
			$tx->attr('name+id', 'item_addselector');
			$tx->description = $this->_('Use a ProcessWire selector to find and add menu items.');

			$tab->add($tx);

		}

		//Drag and drop to sort + reorder menu items area
		$m = $this->modules->get('InputfieldMarkup');
		$m->label = $this->_('Drag & Drop');
		$m->skipLabel = Inputfield::skipLabelHeader;//we don't want a label displayed here
		$m->attr('id', 'dragdrop');

		$m->notes = $this->_('Add items to start building your menu. You can add both Pages (internal links) and Custom (external) links. Drag and drop each item in the order you wish.') . "\n";

		$m->notes .= $this->_('Advanced optional settings can be edited by clicking the "down-arrow" button or the menu item label.');


		//if menu populated, create nested list
		if(count($menuItems)) $m->attr('value', '<div id="menu_sortable_wrapper"><a href="#" id="remove_menus">' . $this->_('Delete All') . '</a>' .
										$this->listMenu(0, $menuItems) . '</div>');

		else $m->attr('value', '<h4>' . $this->_('No items have been added to this menu yet') . '</h4>');

		$tab->add($m);

		return $tab;

	}

	/**
	* Third tab contents for executeEdit()
	*
	* @access protected
	* @param Array $menuItems Array of menu items for a requested menu
	* @return mixed $inputfield markup
	*
	*/
	protected function editTabOverview($menuItems) {

		//Third Tab - Menu item properties overview [read only]. Only show if a menu exists
		$tab = new InputfieldWrapper();
		$tab->attr('title', $this->_('Items Overview'));
		$id = $this->className() . 'Overview';
		$tab->attr('id', $id); 
		$tab->class .= ' WireTab';

		//we'll use this to wrap the table below
		$m = $this->modules->get('InputfieldMarkup');
		$m->label = $this->_('Menu items');
		
		$t = $this->modules->get('MarkupAdminDataTable');
		$t->setEncodeEntities(false);
		$t->setClass('menu_items_table no_disable');
		
		$t->headerRow(array(
			//$this->_('ID'),//id of item in menu; not PW page id!!!
			$this->_('Title'),//for PW pages, actual title saved. The title can also be edited in the add menu item settings
			$this->_('URL'),//path to PW pages + normal url for custom menu items
			$this->_('Parent'),//parent in this menu! NOT PW PAGE PARENT!
			$this->_('CSS ID'),
			$this->_('CSS Class'),
			$this->_('New Tab'),
			$this->_('Type'),//custom or PW page


		));	 	
		
		//fetch menu items and display their properties in the overview table		
		if(count($menuItems)) {

			foreach ($menuItems as $menu => $menuItem) {				

					//if an internal PW page
					if (isset($menuItem['pages_id'])) {
						$itemURL = wire('pages')->get($menuItem['pages_id'])->url;
						$itemType = 'Page';
					}
					
					//else it is a custom menu
					else {

						$itemURL = $menuItem['url'];
						$itemType = 'Custom';

					}

					//check if top tier menu item (has no parent) or below (has a parent)
					if (isset($menuItem['parent_id'])) $itemParent = $menuItems[$menuItem['parent_id']]['title'];
					else $itemParent = '';
				
					//does this menu item link open in a new window or not (i.e. target='_blank') - for custom menu items only
					$itemNewTab = isset($menuItem['newtab']) ? $this->_('Yes') : $this->_('No');

					$itemCSSID = isset($menuItem['css_itemid']) ? $menuItem['css_itemid'] :'';
					$itemCSSClass = isset($menuItem['css_itemclass']) ? $menuItem['css_itemclass'] : '';
				
					$t->row(array(
						$menuItem['title'],
						$itemURL,
						$itemParent,
						$itemCSSID,
						$itemCSSClass,
						$itemNewTab,
						$itemType

					));

			}//end foreach
			
			$m->attr('value', $t->render());			
		
		}//end if count $menuItems
		
		else {		
		
			//user feedback that no menu items have been added to this menu
			$m->description = '<h4>' . $this->_('No items have been added to this menu yet.') . '</h4>';
		
		}
		
		$tab->add($m);

		return $tab;

	}

	/**
	* Fourth tab contents for executeEdit()
	*
	* @access protected
	* @param Int $menuID ID of the menu being edited
	* @return mixed $inputfield markup
	*
	*/
	protected function editTabDelete($menuID) {


		//Fourth Tab - Delete Menu. Only show if a menu exists

		$tab = new InputfieldWrapper();
		$tab->attr('title', $this->_('Delete'));
		$id = $this->className() . 'Delete';
		$tab->attr('id', $id); 
		$tab->class .= " WireTab";
		
		$f = $this->modules->get('InputfieldCheckbox'); 
		$f->attr('id+name', 'menu_delete_confirm'); 
		$f->attr('value', $menuID);
		$f->icon = 'trash-o';
		$f->label = $this->_('Move to Trash');
		$f->description = $this->_('Check the box to confirm you want to do this.');
		$f->label2 = $this->_('Confirm'); 
		$tab->add($f);


		$f = $this->modules->get('InputfieldButton');
		$f->attr('id+name', 'menu_delete'); 
		$f->value = $this->_('Move to Trash');
		$tab->append($f);

		return $tab;

	}

	/**
	* Displays a nested list (menu items) of a single menu.
	* 
	* This is a recursive function to display list of menu items.
	* Also displays each menu's items settings.
	*
	* @access private
	* @param Int $parent ID of menu items.
	* @param Array $menuItems Array of menu items to display.
	* @param Int $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	* @return string $out
	*
	*/		
	private function listMenu($parent = 0, $menuItems = Array(), $first = 0) {
		
		$menuID = (int) $this->input->get->id; 
		
		if($menuID) {	
		
			$has_child = false;
			$out = '';

			/*
				INPUTS

					- id: item id of the menu item in relation to the menu (not same as pages_id!)
					- title: the menu item title as saved in Build Menu (note: even PW native page->title can be customised)
					- parent_id: the parent of this menu item in relation to the menu (note: does not have to reflect PW tree!; top tier items have parent_id = 0)
					- url: the url of the menu item (if PW, use native $page->url; if custom use provided url)
					- css_itemid: this menu item's CSS ID (optional)
					- css_itemclass: this menu items's CSS Class (optional)
					- pages_id: for PW pages items = $page->id; for custom menu items = 0 (note: this is different from id!)

			*/
			
			//$id is = id; $item = arrays of title, url, newtab, etc
			foreach ($menuItems as $id => $item) {

				//set variables
				$title = $item['title'];
				//items without parent ids are top level items
				//we give them an ID of 0 for display purposes (we won't save the value [see wireEncodeJSON()])
				$parent_id = isset($item['parent_id']) ? $item['parent_id'] : 0;
				$url = isset($item['url']) ? $item['url'] : '';
				$cssitemid = isset($item['css_itemid']) ? $item['css_itemid'] : '';
				$cssitemclass = isset($item['css_itemclass']) ? $item['css_itemclass'] : '';
				$pages_id = isset($item['pages_id']) ? $item['pages_id'] : 0;//only PW pages will have a pages_id > 0 (equal to their PW page->id)
				$newtab = isset($item['newtab']) ? $item['newtab'] : 0;

				//PW pages should not have attribute target='_blank' - so no need for checkbox below

				//if dealing with custom menu items
				if($pages_id == 0) {

						$checked = $newtab ? "checked" : '';
						$newTabMarkup = "<label for='newtab{$id}'>
											<input type='checkbox' name='newtab[{$id}]' value='{$id}' class='menu_settings' id='newtab{$id}' {$checked}>" .
											$this->_('Open link in a new tab/window') . 
										"</label>";

						$type = $this->_('Custom');
						$readonly = '';				

				}

				else {

						$type = $this->_('Page');
						$url = wire('pages')->get($pages_id)->path;
						$readonly = ' readonly';
						$newTabMarkup = '';
				}
			
				if ($parent_id == $parent) {//if this menu item is a parent; create the inner-items/child-menu-items
					//if this is the first child output '<ol>' with the class 'sortable'
					if ($has_child === false) {					
						$has_child = true;//This is a parent
						
						if ($first == 0){							
							$out .= "<ol id='sortable_main' class='sortable'>\n";							
							$first = 1;
						}
						
						else {$out .= "\n<ol>\n";}
					}

					//menu item drag n drop handle
					$out .= 
							"<li id='item_{$id}' class='menu_item'>
								<div class='handle'>
								<a href='#' data-id='{$id}' class='item_expand_settings'><i data-id='{$id}' class='fa fa-caret-down'></i></a>
								<span class='item_title_main' data-id='{$id}'>{$title}</span>
								<span class='item_type_wrapper'>
								<span class='item_type'>{$type}</span>
								<a href='#' class='remove_menu'><i class='fa fa-trash'></i></a>
								</span>

								</div>
								\n";
								
					//menu item settings
					$out .= 
					"<div id='menu_edit{$id}' class='settings'>
						<label for='item_title{$id}'>" . $this->_('Title') . "</label>
						<input type='text' value='{$title}' name='item_title[{$id}]' class='menu_settings' id='item_title{$id}'>
						
						<label for='item_url{$id}'>" . $this->_('URL') . "</label>
						<input type='text' value='{$url}' name='item_url[{$id}]' class='menu_settings{$readonly}' id='item_url{$id}' {$readonly}>
						
						<label for='css_itemid{$id}'>". $this->_('CSS ID (single value)') . "</label>
						<input type='text' value='{$cssitemid}' name='css_itemid[{$id}]' class='menu_settings' id='css_itemid{$id}'>
						
						<label for='css_itemclass{$id}'>" . $this->_('CSS Class (single or multiple values separated by space)') . "</label>
						<input type='text' value='{$cssitemclass}' name='css_itemclass[{$id}]' class='menu_settings' id='css_itemclass{$id}'>" .

						$newTabMarkup .
												
						"<input type='hidden' value='{$pages_id}' name='pages_id[{$id}]' class='menu_settings' id='pages_id{$id}'>
						<input type='hidden' value='{$id}' name='item_id[{$id}]' class='menu_settings' id='item_id{$id}'>
						<input type='hidden' value='{$parent_id}' name='item_parent[{$id}]' id='item_parent{$id}'> 
						
					</div>\n";					

					//call function again to generate nested list for sub-menu items belonging to this menu item. 
					$out .= $this->listMenu($id, $menuItems, $first);

					$out .= "</li>\n";
					
				}//end if parent
			
			}//end foreach $menuItems as $id => $item			
		
			if ($has_child === true) $out .= "</ol>\n";
			
			return $out;	

		}//end if menuID		

	}

	/**
	* Hooks into InputfieldAsmSelect::render().
	*
	* Hook modifies AsmSelect output to allow for the use of a custom jquery.asmselect.js
	* The custom js allows to inject two HTML input tags for a selected page menu item.
	* Inputs are for CSS ID and CSS Class of the page selected in the AsmSelect page field.
	*
	* @access protected
	* @param $event The object returned by the hook
	* @return string $value
	*
	*/
	protected function customAsm(HookEvent $event) {

		//$value contains the full rendered markup returned by InputfieldAsmSelect ___render()
		$value = $event->return;
		$value = str_replace("\"multiple\"", "\"multipleMB\"", $value);

		//set the modified value back to the return value 
		$event->return = $value;

	}

	/**
	* Hooks into InputfieldPageAutocomplete::renderListItem().
	*
	* Hook modifies PageAutocomplete output to append two extra HTML inputs.
	* The hook complete replaces the method.
	* Inputs are for CSS ID and CSS Class of the page selected in the Autocomplete page field.
	*
	* @access protected
	* @param $event The object returned by the hook
	* @return string $out
	*
	*/
	protected function customAc(HookEvent $event) {

		/*
			- Every ProcessWire hook is passed an object called $event (of type HookEvent). 
			- This object contains an arguments() method that you can access to retrieve the arguments of the method either by index or name.
			- renderListItem() accepts three arguments:
			- renderListItem($label, $value, $class = '')
		*/

		$class = " " . $event->arguments('class');//note the space! This will be appended to other CSS classes
		$label = $event->arguments('label');//label () to display for the sortable li
		$value = $event->arguments('value');//selected items values (typically page->id)		

		//here we just add the <span><input></span> to the default renderListItem() Markup
		$extraInput = 
						'<span class="acMB"><input name="new_page_css_itemid[]" type="text">
							<input name="new_page_css_itemclass[]" type="text">
						</span>';

		//we don't want extra input in the default template (one with $label='Label', $class='itemTemplate', $value='1')
		if($label =='Label' && $class == 'itemTemplate') $extraInput = '';

		$event->replace = true;//we want to entirely replace the method

		$out = 
				"\n<li class='ui-state-default" . $class . "'>" . 
				"<i class='fa fa-sort fa-fw'></i> " . 
				"<span class='itemValue'>" . $value . "</span>" . 
				"<span class='itemLabel'>" . $label . "</span> " . 
				"<a class='itemRemove' href='#'><i class='fa fa-trash'></i></a>" . 
				$extraInput .	"</li>";

		//set the modified value back to the return value 
		$event->return = $out;

	}

	/**
	* Outputs javascript configuration values for nestedSortable.
	*
	* @access protected
	* @param String $menuSettings JSON string of a menu's settings.
	* @return string $scripts
	*
	*/
	protected function nestedSortableConfigs($menuSettings) {

		//our default nestedSortable settings 
		$nestedSortableOptions = array(

						'config' => array(
									'maxLevels' => 0,
									'disableParentChange' => 'false',
									'expandOnHover' => 700,
									'protectRoot' => 'false',
									'rtl' => 'false',
									'startCollapsed'=>'false',
									'tabSize' => 20,
									'doNotClear' => 'false',
									'isTree' => 'true',
						)

		);

		//convert saved custom settings (JSON) to array
		$menuSettings = json_decode($menuSettings, true);

		//if custom settings found, we overwrite default ones
		if(count($menuSettings)){
			
				foreach ($menuSettings as $key => $value) $nestedSortableOptions['config'][$key] = $value['setting'];

		}

		$scripts = $this->config->js($this->className(), $nestedSortableOptions);

		return $scripts;

	}

	/**
	* Outputs saved menu settings for editing configuration values for nestedSortable.
	*
	* Settings will only be available to supersusers
	*
	* @access protected
	* @param String $menuSettings JSON string of a menu's settings.
	* @return array $mergedMenuSettings
	*
	*/
	protected function nestedSortableMenuSettings($menuSettings) {

		
		$mlNote = $this->_('The maximum depth of nested items the list can accept. If set to \'0\' the levels are unlimited.');
		$dpcNote = $this->_('Set this to') . ' true '; 
		$dpcNote .= $this->_('to lock the parentship of items. They can only be re-ordered within their current parent container.');
		$eonNote = $this->_('How long (in milliseconds) to wait before expanding a collapsed node (useful only if') . ' isTree: true).';
		$prNote = $this->_('Whether to protect the root level (i.e. root items can be sorted but not nested, sub-items cannot become root items.)');
		$rltNote = $this->_('Set this to') . ' true ';
		$rltNote .= $this->_('if you have a right-to-left page.');
		$scNote = $this->_('Set this to') . ' true ';
		$scNote .= $this->_('if you want the plugin to collapse the tree on page load.');
		$tsNote = $this->_('How far right or left (in pixels) the item has to travel in order to be nested or to be sent outside its current list.');
		$dncNote = $this->_('Set this to') .  ' true ';
		$dncNote .= $this->_('if you do not want empty lists to be removed.');
		$treeNote = $this->_('Nested list to behave as a tree with expand/collapse functionality.');


		//default menu settings array to be merged and displayed in menu settings table	in 'Main' Tab
		$defaultMenuSettings = array(
					'maxLevels' => array('default'=>0, 'setting'=>'', 'notes'=> $mlNote),
					'disableParentChange' => array('default'=>'false', 'setting'=>'', 'notes'=> $dpcNote),
					'expandOnHover' => array('default'=>700, 'setting'=>'', 'notes'=> $eonNote),
					'protectRoot' => array('default'=>'false', 'setting'=>'', 'notes'=> $prNote),
					'rtl' => array('default'=>'false', 'setting'=>'', 'notes'=> $rltNote),
					'startCollapsed' => array('default'=>'false', 'setting'=>'', 'notes'=> $scNote),
					'tabSize' => array('default'=>20, 'setting'=>'', 'notes'=> $tsNote),
					'doNotClear' => array('default'=>'false', 'setting'=>'', 'notes'=> $dncNote),
					'isTree' => array('default' =>'true', 'setting'=>'', 'notes'=> $treeNote),
		);

		$menuSettings = json_decode($menuSettings, true);
		if(!is_array($menuSettings)) $menuSettings = array();

		$mergedMenuSettings = array_replace_recursive($defaultMenuSettings, $menuSettings);

		return $mergedMenuSettings;

	}
	
	/**
	* Processes ProcessMenuBuilder form inputs (CRUD).
	*	
	* CRUD - Processes all the form input sent from execute() and executeEdit().
	*	
	* @param mixed $form Sent form values
	* @access private
	*	
	*/
	private function save($form) {

		//process form
		$form->processInput($this->input->post); 

		$menuID = (int) $this->input->post->menu_id;

		$newPublishedBtn = $this->input->post->menu_new_published_btn;
		$newUnpublishedBtn = $this->input->post->menu_new_unpublished_btn;

		//menus bulk actions button and select
		$actionsMenusBtn = $this->input->post->menus_action_btn;
		$action = $this->input->post->menus_action_select;

		$saveBtn = $this->input->post->menu_save;
		$saveAndExitBtn = $this->input->post->menu_save_exit;
		
		$menuDelete = $this->input->post->menu_delete;//changed to hidden input from button in ProcessMenuBuilder.js
		$menuDeleteConfirm = $this->input->post->menu_delete_confirm;//checkbox to confirm trash

		//save new menu(s)
		if (($newUnpublishedBtn && $newUnpublishedBtn == 'Save Unpublished') || ($newPublishedBtn && $newPublishedBtn == 'Publish') ){
	
				$addMenus = $this->input->post->menus_add_text;//$addMenus will be a string of text separated by a new line (\n).
								
				if ($addMenus) {
						
						$menus = explode("\n", $addMenus);//convert to an array			
						
						//Sanitize and save new menus

						$i = 0;//set counter for number of categories added
						foreach ($menus as $m) {
							$p = new Page();
							$p->parent = $this->menusParent;
							$p->template = wire('templates')->get("menus");
							$p->title = $this->sanitizer->text($m);
							if (!$p->title) continue;//skip to next if no title provided
							if ($p->title) $p->name = $this->sanitizer->pageName($p->title);//sanitize and convert to a URL friendly page name

							//check if name already taken
							if($p->parent->child("name={$p->name}, include=all")->id) {
							
								//if the name already exists, add it to the $failed array [to display to user in error message later] and skip to next title
								$failed [] = $p->title;
								continue;
							}

							//if user pressed 'save unpublished', we save new menus unpublished
							if ($newUnpublishedBtn) $p->addStatus(Page::statusUnpublished);
							$p->save();
							$i++;

						}//end foreach $menus as $m

						//create a string of "failed" menu titles to add to error message
						$failedTitles = implode(', ', $failed); 

						if($i > 0) $this->message(sprintf(_n("Added %d new menu.", "Added %d new menus.", $i), $i));//tell user how many menus were added
						if($failedTitles) $this->error($this->_("Some menus not added because names already in use. These are: {$failedTitles}."));
						$this->session->redirect(wire('page')->url);//redirect to landing page

				}//end if $addMenus

				else {
						//show error message if add button clicked without first entering some categories to add
						$this->error($this->_("You need to add some menus."));
				}

		}//end add new menus
		

		//apply bulk actions to menus

		//@@todo - unsure if to allow actions for user without edit permission?
		//e.g. if (!$m->editable()) continue; //Only action if current user can edit
		
		//menus bulk actions
		elseif($actionsMenusBtn && $actionsMenusBtn == 'Apply') {//was the right button pressed
				
				if (!$action) {
					$this->error($this->_("You need to select an action."));
					return false;
				}
				
				$actionMenus = $this->input->post->menus_action;//checkbox array name

				//check if menus were selected. 
				if ($actionMenus) {

						//prepare sent menu IDs to find and TRASH the menu pages	
						$menuIds = implode('|', $actionMenus);//split array elements, joining them with pipe (I) to use in selector
						
						$menus = wire('pages')->find("id={$menuIds}, include=all");

						$i = 0;
						
						if ($action == 'publish') {
								foreach ($menus as $m) {
											$m->removeStatus(Page::statusUnpublished);
											$m->save();
											$i++;
								}

								$msg = sprintf(_n("Published %d menu.", "Published %d menus.", $i), $i);

						}//end publish menus

						elseif ($action == 'unpublish') {
								foreach ($menus as $m) {
											$m->addStatus(Page::statusUnpublished);
											$m->save();
											$i++;
								}
						
								$msg = sprintf(_n("Unpublished %d menu.", "Unpublished %d menus.", $i), $i);

						}//end unpublish menus
						
						elseif ($action == 'lock') {
								foreach ($menus as $m) {
											$m->addStatus(Page::statusLocked);
											$m->save();
											$i++;
								}
						
								$msg = sprintf(_n("Locked %d menu.", "Locked %d menus.", $i), $i);

						}//end lock menus

						elseif ($action == 'unlock') {
								foreach ($menus as $m) {
											$m->removeStatus(Page::statusLocked);
											$m->save();
											$i++;
								}
						
								$msg = sprintf(_n("Unlocked %d menu.", "Unlocked %d menus.", $i), $i);

						}//end unlock menus

						elseif ($action == 'trash') {
								foreach ($menus as $m) {
									$m->trash();
									$i++;
								}
								
								$msg = sprintf(_n("Trashed %d menu.", "Trashed %d menus.", $i), $i);

						}//end trash menus
						
						elseif ($action == 'delete') {
								foreach ($menus as $m) {
									$m->delete();
									$i++;
								}
								
								$msg = sprintf(_n("Deleted %d menu.", "Deleted %d menus.", $i), $i);

						}//end delete menus

						$this->message($msg);//tell user how many menus were 'actioned'
						$this->session->redirect(wire('page')->url);//redirect to page where we were

				}

				else {
						//show error message if apply action button clicked without first selecting menus
						$this->error($this->_('You need to select at least one menu before applying an action.'));
						return false;
				}
		
		}//end menus bulk actions

		//save specified menu		
		elseif($saveBtn == 'Save'|| $saveAndExitBtn == 'Save & Exit') {

		
		// ================ SAVE SINGLE EXISTING MENU (executeEdit()) =====================
			
				$menu = wire('pages')->get($menuID);

				//if we didn't get a menu, exit with an error
				if(!$menu->id) {
						$this->error($this->_('Error saving Menu.')); 
						return false;
				}

				//if menu is locked for editing, exit with an error
				if($menu->is(Page::statusLocked)) {
						$this->error($this->_('This menu is locked for edits.')); 
						$this->session->redirect(wire('page')->url. 'edit/?id=' . $menuID);//redirect back to the menu we were editing
				}
			
		
				#################	01. Process menu settings: First TAB - 'Main' 	#################

				$menuTitle = $this->sanitizer->text($this->input->post->menu_title);

				//if no title provided, halt proceedings and show error message
				if (!$menuTitle) {
					$this->error($this->_('A title is required.')); 
					return false;
				}	

				$menuPages = array();

				//nestedSortable settings for this menu. we'll save this as JSON in menu_settings field
				$menuSettings = array();


				//only save for Superusers
				//ensures their settings are not overwritten (although hidden for other users)
				if ($this->user->isSuperuser()) {
					//selector for finding pages that can be added to the menu (for AsmSelect/Autocomplete)				
					$menuPages['sel'] = $this->sanitizer->text($this->input->post->menu_pages);

					//page inputfield type for finding pages that can be added to the menu (AsmSelect vs. Autocomplete)
					//we only save this if user selects Autcomplete; otherwise defaults to AsmSelect			
					$menuPages['input'] = (int) $this->input->post->menu_pages_select == 2 ? 2 : '';

					//whether to allow HTML markup in menu item titles/lables -> e.g. <span>Home</span>
					//we only save this if user selects Yes; otherwise defaults to No (don't allow markup)
					//we'll then use the correct sanitizer below			
					$allowMarkup = $menuPages['markup'] = (int) $this->input->post->menu_item_title_markup == 1 ? 1 : '';

					//nestedSortable settings
					foreach ($this->input->post->menu_settings as $key => $value) {

						//only save non-empty $key => $values
						if($value) {
							if($key == 'maxLevels' || $key == 'expandOnHover' || $key == 'tabSize') $value = (int) $value;
							else $value = $this->sanitizer->text($value);

							$menuSettings[$key]['setting'] = $value;
						}
					}

				}


				//JSON string of menu settings to save
				$menuSettingsJSON = count($menuSettings) ? json_encode($menuSettings) : '';

				
				#################	02. Process EXISTING menu items first 	#################
						
				//array to hold our all our menu items
				$menuItems = array();

				//loop through the existing, updated menu items sent from nestedSortable
				//only loop if we have existing menu times. we check the hidden field with IDs of menu items
				if(count($this->input->post->item_id)) {


							if($allowMarkup) $purifier = $this->modules->get('MarkupHTMLPurifier');

							foreach($this->input->post->item_id as $itemID) {

									$itemID = (int) $itemID;
									if(!$itemID) continue;

									//if menu items titles allow HTML (markup) && user is Superuser, we run them though HTML purifier
									if($allowMarkup && $this->user->isSuperuser()) $itemTitle = $purifier->purify($this->input->post->item_title[$itemID]);
									//else we sanitize menu item titles as text
									else$itemTitle =  $this->sanitizer->text($this->input->post->item_title[$itemID]);
									
									if(!$itemTitle) continue;
						
									$itemURL = $this->sanitizer->url($this->input->post->item_url[$itemID]); 
									if(!$itemURL) continue;
									
									$itemPagesID = (int) $this->input->post->pages_id[$itemID];						
									$itemURL = $itemPagesID == 0 ? $itemURL : '';//only save custom (external to PW) items links				
									$itemParent = (int) $this->input->post->item_parent[$itemID];//the item's parent in relation to the menu (not PW page menu!)								
									$itemCSSID = $this->sanitizer->name($this->input->post->css_itemid[$itemID]);//single value						
									$itemCSSClass = $this->sanitizer->text($this->input->post->css_itemclass[$itemID]);//sanitizer->text to accept multiple classes						
									$itemNewTab = isset($this->input->post->newtab[$itemID]) ? 1 : '';//only save for custom menu items with target='_blank'

									$menuItems[$itemID] = array(

											'title' => $itemTitle, 
											'parent_id' => $itemParent,
											'url' => $itemURL,
											'css_itemid' => $itemCSSID,
											'css_itemclass' => $itemCSSClass,
											'pages_id' => $itemPagesID,
											'newtab' => $itemNewTab,
									);

							}//end foreach loop for existing menu items

					}//end if count $this->input->post->item_id

				//we'll need this to auto-increment menu IDs for new menu items (to ensure uniqueness)
				$lastID = count($menuItems) ? max(array_keys($menuItems)) : 0;//will give us the highest numbered array key (the itemID)

				
				#################	03: Process NEW custom menu items 	#################
				
				/*	Values coming from two sources: Custom menu links & PW pages added to menu
				*	Tack these at the bottom of the menuItems array
				*	Give them parent = 0 (i.e. top tier until drag & drop later)
				*	
				*/
					
				//add the new custom menu item links. Cannot add new pages here since their count may be different	
				$count = count($this->input->post->new_item_custom_title);

				$menuItemID = $lastID + 1;

				for ($i = 0; $i < $count; $i++) {	
			
					$itemTitle = $this->sanitizer->text($this->input->post->new_item_custom_title[$i]);
					if (!$itemTitle) continue;
					
					//$newpages_id = '';//not needed. New items, hence new $ids will be auto-created
					$itemURL = $this->sanitizer->url($this->input->post->new_item_custom_url[$i]);
					if (!$itemURL) continue;//only accept new menu items with URLs. @@todo - should this be the case? What if they want a divider like item?
					
					$itemCSSID = $this->sanitizer->name($this->input->post->new_css_itemid[$i]);
					$itemCSSClass = $this->sanitizer->name($this->input->post->new_css_itemclass[$i]);
					$itemNewTab = (!isset($this->input->post->new_newtab[$i])) ? '' : 1;
					
					//add custom (external) menu items to our menu
					$menuItems[$menuItemID] = array(

							'title' => $itemTitle, 
							'parent_id' => 0,//for new items (before potentially moved to other tiers in drag & drop)
							'url' => $itemURL,
							'css_itemid' => $itemCSSID,
							'css_itemclass' => $itemCSSClass,
							'pages_id' => '',
							'newtab' => $itemNewTab,
					);

					$menuItemID++;
					
				}//end for loop for new custom items


				#################	04: Process NEW menu items from PW Pages 	#################

				$addPages = $this->input->post->item_addpages;
				$pagesCSSClass = $this->input->post->new_page_css_itemclass;
				$pagesCSSID = $this->input->post->new_page_css_itemid;
				$menuPagesInput = $this->input->post->menu_pages_input;

				//if using PageAutocomplete in the 'add pages to menu select'
				if($menuPagesInput == 2) {

					//In the autocomplete select array, there is only one index with a string of numbers, e.g. ,1087,1364,7895 as a value
					$addPages = explode(",", $addPages[0]);

					//we remove the first item in the array since it will be an empty string.
					array_splice($addPages, 0, 1);

					//we also remove the correspodningfirst item in the array since it will be an empty string.
					array_splice($pagesCSSID, 0, 1);
					array_splice($pagesCSSClass, 0, 1);

				}

				$count = count($addPages);

				for ($i = 0; $i < $count; $i++) {
				
					//if there are menu items added from the AsmSelect, add them to the menu
					$itemID = (int) $addPages[$i];//sanitize: we need this to be an integer

					$itemTitle = wire('pages')->get($itemID)->title;//title of each PW page in this array
					if(!$itemTitle) continue;// if no new pages posted, move one...[otherwise one iteration with empty strings is added to array!]

					$itemCSSID = $this->sanitizer->name($pagesCSSID[$i]);
					$itemCSSClass = $this->sanitizer->text($pagesCSSClass[$i]);
					
					//add PW pages (internal) menu items to our menu
					$menuItems[$menuItemID] = array(

							'title' => $itemTitle,
							'parent_id' => 0,//for new items before they are sorted in drag & drop
							//'url' => '',//empty since these are PW pages; no needed to copy URL here + need to make sure always have latest
							'css_itemid' => $itemCSSID,
							'css_itemclass' => $itemCSSClass,
							'pages_id' => $itemID,//the PW page ID
							//'newtab' => ''//NOT necessary for PW pages
					);

					$menuItemID++;

				}//end for loop for new page items



				#################	05: Process NEW menu items from Selector 	#################

				$items = array();
				
				$selectorPages = $this->sanitizer->text($this->input->post->item_addselector);
				if($selectorPages) $items = wire('pages')->find($selectorPages);

				if (count($items)) {

					foreach ($items as $item) {
						
							//add PW pages (internal) menu items from the selector to our menu
							$menuItems[$menuItemID] = array(

									'title' => $item->title,
									'parent_id' => 0,//for new items before they are sorted in drag & drop
									//'url' => '',//empty since these are PW pages; no needed to copy URL here + need to make sure always have latest
									//'css_itemid' => ''//empty until edited
									//'css_itemclass' => ''//empty until edited
									'pages_id' => $item->id,//the PW page ID
									//'newtab' => ''//NOT necessary for PW pages
							);

							$menuItemID++;

					}//end foreach $items as $item

				}//end if count($items)


				//JSON string of menu pages and menu items to save
				$menuPagesJSON = count($menuPages) ? wireEncodeJSON($menuPages) : '';//using wireEncodeJSON ensures we only save non-empty values
				$menuitemsJSON = count($menuItems) ? wireEncodeJSON($menuItems) : '';


				#################	06: Save menu 	#################
									
				$menu->title = $menuTitle;
				$menu->name = $this->sanitizer->pageName($menuTitle);
				if($this->user->isSuperuser()) $menu->menu_pages = $menuPagesJSON;//only save for supersusers
				$menu->menu_items = $menuitemsJSON;
				if($this->user->isSuperuser()) $menu->menu_settings = $menuSettingsJSON;//only save for supersusers			
				
				$menu->save();
				
				$this->message($this->_('Saved Menu: '. $menu->title)); 
				if($saveAndExitBtn) $this->session->redirect(wire('page')->url); 
				else $this->session->redirect(wire('page')->url. 'edit/?id=' . $menuID);//redirect back to the menu we were editing

		}//end elseif save menu
		
		//delete menu
		elseif ($menuDelete) {	

					if($menuDeleteConfirm) {

							$menu = wire('pages')->get("id=$menuDeleteConfirm, parent=$this->menusParent, include=all");

							if(wire('pages')->trash($menu)) {
									$this->message(sprintf($this->_('Moved menu %1$s to trash: %2$s'), $menu->title, $menu->url));//tell user menu trashed
									$this->session->redirect(wire('page'))->url;							
							}

							else { 
									$this->error($this->_('Unable to move menu to trash'));//menu can't be moved to the trash error
									return false;
							}

					}//end if confirm delete
				
		}//end elseif delete menu

	}	
	
	/**
	* Called only when the module is installed.
	*
	* A new page with this Process module assigned is created. 
	* A new permission 'menu-builder' is created.
	*
	* @access public
	*
	*/	
	public function ___install() {	
	
		//installer for templates and fields + their tags  to be used by Menu Builder

		$fields = array(

		'menu_pages' => array('name'=>'menu_pages', 'type'=> 'FieldtypeText', 'label'=>'Menu Pages', 'description'=>'JSON formatted values of optional ProcessWire selector to limit pages that can be added to this menu, whether to allow HTML (markup) in menu item titles and whether to use AsmSelect or PageAutocomplete in adding menu items. Example JSON: {"sel":"template=colours, limit=20, sort=title","input":2}. You don\'t need to edit these directly. Use Menu Builder instead.', 'maxlength'=>2048),
		'menu_items' => array('name'=>'menu_items', 'type'=> 'FieldtypeTextarea', 'label'=>'Menu Items', 'description'=>'JSON values of the items in this menu. You don\'t need to edit these directly. Use Menu Builder instead.'),
		'menu_settings' => array('name'=>'menu_settings', 'type'=> 'FieldtypeTextarea', 'label'=>'Menu Settings', 'description'=>'JSON values of this menu\'s settings. You don\'t need to edit these directly. Use Menu Builder instead.'),

		);

		//first check that we don't already have fields named same as menu builderss
		foreach ($fields as $field) {

			//if we do, we abort before installing the module
			if(wire('fields')->get($field['name'])) {
				throw new WireException($this->_("Aborted installation. Confirm that you do not have fields called 'menu_pages', 'menu_settings' and 'menu_items' before installing this module."));
				
			}
		}


		//check that we already don't have a template named same as menu builder's
		//if we do, we abort before installing the module
		if(wire('templates')->get('menus')) {
				throw new WireException($this->_("Aborted installation. Confirm that you do not have a template called 'menus' before installing this module."));
				
		}

		//if no errors, we are good to go

		//create our 3 fields
		foreach ($fields as $field) {

			$f = new Field(); //create new field object
			$f->type = $this->modules->get($field['type']); //get a field type
			$f->name = $field['name'];
			$f->label = $field['label'];
			$f->description = $field['description'];
			$f->collapsed = 5;
			if ($field['name'] == 'menu_pages') $f->maxlength = $field['maxlength'];
			if ($field['name'] != 'menu_pages') $f->rows = 10;

			$f->tags = 'menu';
			$f->save(); //

		}//end foreach fields


		//create our 1 template + add above fields
		//new fieldgroup
		$fg = new Fieldgroup();
		$fg->name = 'menus';

		//add title field
		$title = wire('fields')->get('title');
		$fg->add($title);

		foreach ($fields as $key => $value) {
			
				$f = wire('fields')->get($key);
				$fg->add($f);
		}

		//save fieldgroup
		$fg->save();
		$this->message('Created Fields: menu_pages, menu_items, menu_settings');

		//create a new template to use with this fieldgroup
		$t = new Template();
		$t->name = 'menus';
		$t->fieldgroup = $fg; //add the fieldgroup

		//add template settings we need
		$t->label = 'Menus';
		$t->noChildren = 1;//the pages using this template should not have children
		$t->parentTemplates = array(wire('templates')->get('admin')->id);//needs to be added as array of template IDs. Allowed template for parents = 'admin'
		$t->tags = 'menu';

		//save new template with fields and settings now added
		$t->save();
		$this->message('Created Template: menus');

		//create menu builder page and permission
		$page = $this->pages->get('template=admin, name='.self::PAGE_NAME);
		if (!$page->id) {
				$page = new Page();
				$page->template = 'admin';
				$page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');
				$page->title = 'Menu Builder';
				$page->name = self::PAGE_NAME;
				$page->process = $this;
				$page->save();
			
			//tell the user we created this page
			$this->message("Created Page: {$page->path}");
		
		}
		
		$permission = $this->permissions->get('menu-builder');
		if (!$permission->id) {
				$p = new Permission();
				$p->name = 'menu-builder';
				$p->title = $this->_('View Menu Builder Page');
				$p->save();			
			
				//tell the user we created this module's permission
				$this->message('Created New Permission: menu-builder');			
		}		
	
	}

	/**
	* Called only when the module is uninstalled.
	*
	* This should return the site to the same state it was in before the module was installed.
	* Deletes
	*
	* @access public
	*
	*/	 
	public function ___uninstall() {
		
		//find and delete the page we installed, locating it by the process field (which has the module ID)
		//it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->modules->getModuleID($this); 
		$page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 
		//$page = $this->pages->get('template=admin, name='.self::PAGE_NAME);
			
		if($page->id) {
			//if we found the page, let the user know and delete it
			$this->message($this->_('Deleted Page: ') . $page->path); 
			//recursively delete the menu builder page (i.e. including all its children (the menus))
			wire('pages')->delete($page, true);
		}

		//find and delete the menu builder permission and let the user know
		$permission = $this->permissions->get('menu-builder');
		if ($permission->id){
			$permission->delete();
			$this->message('Deleted Permission: menu-builder');
		
		}

		//find and delete our menus template
		$t = wire('templates')->get('menus');

		if ($t->id) {

			wire('templates')->delete($t);
			wire('fieldgroups')->delete($t->fieldgroup);//delete the associated fieldgroups
			$this->message('Deleted Template: menus');

		}

		//find and delete the 3 fields used by our menus
		$fields = array('menu_pages', 'menu_items', 'menu_settings');
		foreach ($fields as $field) {

					$f = wire('fields')->get($field);
					if($f->id) wire('fields')->delete($f);	
					$this->message('Deleted Fields: menu_pages, menu_items, menu_settings');
		
		}
	
	}	

	
}
